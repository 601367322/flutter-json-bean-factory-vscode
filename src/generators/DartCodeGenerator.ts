import { JsonClass, JsonProperty } from '../parsers/JsonParser';
import * as vscode from 'vscode';

export interface GeneratorConfig {
    nullSafety: boolean;
    useJsonAnnotation: boolean;
    classNamePrefix: string;
    classNameSuffix: string;
    generatedPath: string;
    entityPath: string;
    forceNonNullable: boolean;  // 强制所有字段非空
    addNullChecks: boolean;     // 在fromJson中添加null检查
    useAsserts: boolean;        // 使用assert进行验证
    generateToString: boolean;  // 生成toString方法
    generateEquality: boolean;  // 生成==和hashCode方法
    scanPath: string;           // 扫描现有models的路径
}

export class DartCodeGenerator {
    private config: GeneratorConfig;
    private packageName: string;

    constructor(config?: Partial<GeneratorConfig>, packageName: string = 'your_app') {
        const defaultConfig: GeneratorConfig = {
            nullSafety: true,
            useJsonAnnotation: true,
            classNamePrefix: '',
            classNameSuffix: '',
            generatedPath: 'lib/generated/json',
            entityPath: 'lib/models',
            forceNonNullable: false,
            addNullChecks: true,
            useAsserts: false,
            generateToString: true,
            generateEquality: false,
            scanPath: 'lib'
        };

        this.config = { ...defaultConfig, ...config };
        this.packageName = packageName;
    }

    /**
     * Generate Dart class code (entity file)
     */
    generateDartClass(jsonClass: JsonClass): string {
        const className = this.getClassName(jsonClass.name);
        const imports = this.generateEntityImports(className);
        const classDeclaration = this.generateEntityClassDeclaration(className, jsonClass.properties);

        return [
            imports,
            '',
            classDeclaration
        ].join('\n');
    }

    /**
     * Generate helper file for JSON conversion (original style)
     */
    generateHelperFile(jsonClass: JsonClass): string {
        const className = this.getClassName(jsonClass.name);
        const imports = this.generateHelperImports(className);
        const fromJsonFunction = this.generateFromJsonFunction(className, jsonClass.properties);
        const toJsonFunction = this.generateToJsonFunction(className, jsonClass.properties);
        const copyWithExtension = this.generateCopyWithExtension(className, jsonClass.properties);

        return [
            imports,
            '',
            fromJsonFunction,
            '',
            toJsonFunction,
            '',
            copyWithExtension
        ].join('\n');
    }

    /**
     * Generate base JSON convert file (original style with dynamic updates)
     */
    generateBaseJsonConvert(allClasses: JsonClass[] = []): string {
        const imports = this.generateJsonConvertImports(allClasses);
        const getListChildType = this.generateGetListChildType(allClasses);
        const convertFuncMap = this.generateConvertFuncMap(allClasses);

        return `// ignore_for_file: non_constant_identifier_names
// ignore_for_file: camel_case_types
// ignore_for_file: prefer_single_quotes

// This file is automatically generated. DO NOT EDIT, all your changes would be lost.
import 'package:flutter/material.dart' show debugPrint;
${imports}

JsonConvert jsonConvert = JsonConvert();

typedef JsonConvertFunction<T> = T Function(Map<String, dynamic> json);
typedef EnumConvertFunction<T> = T Function(String value);
typedef ConvertExceptionHandler = void Function(Object error, StackTrace stackTrace);
extension MapSafeExt<K, V> on Map<K, V> {
  T? getOrNull<T>(K? key) {
    if (!containsKey(key) || key == null) {
      return null;
    } else {
      return this[key] as T?;
    }
  }
}

class JsonConvert {
  static ConvertExceptionHandler? onError;
  JsonConvertClassCollection convertFuncMap = JsonConvertClassCollection();

  /// When you are in the development, to generate a new model class, hot-reload doesn't find new generation model class, you can build on MaterialApp method called jsonConvert. ReassembleConvertFuncMap (); This method only works in a development environment
  /// https://flutter.cn/docs/development/tools/hot-reload
  /// class MyApp extends StatelessWidget {
  ///    const MyApp({Key? key})
  ///        : super(key: key);
  ///
  ///    @override
  ///    Widget build(BuildContext context) {
  ///      jsonConvert.reassembleConvertFuncMap();
  ///      return MaterialApp();
  ///    }
  /// }
  void reassembleConvertFuncMap() {
    bool isReleaseMode = const bool.fromEnvironment('dart.vm.product');
    if (!isReleaseMode) {
      convertFuncMap = JsonConvertClassCollection();
    }
  }

  T? convert<T>(dynamic value, {EnumConvertFunction? enumConvert}) {
    if (value == null) {
      return null;
    }
    if (value is T) {
      return value;
    }
    try {
      return _asT<T>(value, enumConvert: enumConvert);
    } catch (e, stackTrace) {
      debugPrint('asT<\$T> \$e \$stackTrace');
      if (onError != null) {
        onError!(e, stackTrace);
      }
      return null;
    }
  }

  List<T?>? convertList<T>(List<dynamic>? value,
      {EnumConvertFunction? enumConvert}) {
    if (value == null) {
      return null;
    }
    try {
      return value.map((dynamic e) => _asT<T>(e, enumConvert: enumConvert))
          .toList();
    } catch (e, stackTrace) {
      debugPrint('asT<\$T> \$e \$stackTrace');
      if (onError != null) {
        onError!(e, stackTrace);
      }
      return <T>[];
    }
  }

  List<T>? convertListNotNull<T>(dynamic value,
      {EnumConvertFunction? enumConvert}) {
    if (value == null) {
      return null;
    }
    try {
      return (value as List<dynamic>).map((dynamic e) =>
      _asT<T>(e, enumConvert: enumConvert)!).toList();
    } catch (e, stackTrace) {
      debugPrint('asT<\$T> \$e \$stackTrace');
      if (onError != null) {
        onError!(e, stackTrace);
      }
      return <T>[];
    }
  }

  T? _asT<T extends Object?>(dynamic value,
      {EnumConvertFunction? enumConvert}) {
    final String type = T.toString();
    final String valueS = value.toString();
    if (enumConvert != null) {
      return enumConvert(valueS) as T;
    } else if (type == "String") {
      return valueS as T;
    } else if (type == "int") {
      final int? intValue = int.tryParse(valueS);
      if (intValue == null) {
        return double.tryParse(valueS)?.toInt() as T?;
      } else {
        return intValue as T;
      }
    } else if (type == "double") {
      return double.parse(valueS) as T;
    } else if (type == "DateTime") {
      return DateTime.parse(valueS) as T;
    } else if (type == "bool") {
      if (valueS == '0' || valueS == '1') {
        return (valueS == '1') as T;
      }
      return (valueS == 'true') as T;
    } else if (type == "Map" || type.startsWith("Map<")) {
      return value as T;
    } else {
      if (convertFuncMap.containsKey(type)) {
        if (value == null) {
          return null;
        }
        var covertFunc = convertFuncMap[type]!;
        if (covertFunc is Map<String, dynamic>) {
          return covertFunc(value as Map<String, dynamic>) as T;
        } else {
          return covertFunc(Map<String, dynamic>.from(value)) as T;
        }
      } else {
        throw UnimplementedError(
            '\$type unimplemented,you can try running the app again');
      }
    }
  }

  //list is returned by type
${getListChildType}

  static M? fromJsonAsT<M>(dynamic json) {
    if (json is M) {
      return json;
    }
    if (json is List) {
      return _getListChildType<M>(
          json.map((dynamic e) => e as Map<String, dynamic>).toList());
    } else {
      return jsonConvert.convert<M>(json);
    }
  }
}

${convertFuncMap}`;
    }

    /**
     * Generate json_field.dart file (fixed content)
     */
    generateJsonField(): string {
        return `// ignore_for_file: non_constant_identifier_names
// ignore_for_file: camel_case_types
// ignore_for_file: prefer_single_quotes

// This file is automatically generated. DO NOT EDIT, all your changes would be lost.

import 'package:meta/meta_meta.dart';

@Target({TargetKind.classType})
class JsonSerializable {
  const JsonSerializable();
}

@Target({TargetKind.field})
class JSONField {
  //Specify the parse field name
  final String? name;

  //Whether to participate in toJson
  final bool? serialize;

  //Whether to participate in fromMap
  final bool? deserialize;

  //Whether to participate in copyWith
  final bool? copyWith;

  //Enumeration or not
  final bool? isEnum;

  const JSONField({this.name, this.serialize, this.deserialize, this.isEnum, this.copyWith});
}`;
    }

    private generateEntityImports(className: string): string {
        const snakeClassName = this.toSnakeCase(className);
        return `import 'package:${this.packageName}/generated/json/base/json_field.dart';
import 'package:${this.packageName}/generated/json/${snakeClassName}.g.dart';
import 'dart:convert';
export 'package:${this.packageName}/generated/json/${snakeClassName}.g.dart';`;
    }

    private generateHelperImports(className: string): string {
        const snakeClassName = this.toSnakeCase(className);
        return `import 'package:${this.packageName}/generated/json/base/json_convert_content.dart';
import 'package:${this.packageName}/models/${snakeClassName}.dart';`;
    }

    private generateEntityClassDeclaration(className: string, properties: JsonProperty[]): string {
        const parts = [];

        // Add @JsonSerializable() annotation
        parts.push('@JsonSerializable()');
        parts.push(`class ${className} {`);

        // Add properties with default values (original style)
        for (const prop of properties) {
            const defaultValue = this.getDefaultValue(prop);
            parts.push(`\t${prop.dartType} ${prop.name} = ${defaultValue};`);
        }

        parts.push('');
        parts.push(`\t${className}();`);
        parts.push('');

        // Add factory fromJson method that calls global function
        const functionName = `$${className}FromJson`;
        parts.push(`\tfactory ${className}.fromJson(Map<String, dynamic> json) => ${functionName}(json);`);
        parts.push('');

        // Add toJson method that calls global function
        const toJsonFunctionName = `$${className}ToJson`;
        parts.push(`\tMap<String, dynamic> toJson() => ${toJsonFunctionName}(this);`);
        parts.push('');

        // Add toString method using jsonEncode
        parts.push('\t@override');
        parts.push('\tString toString() {');
        parts.push('\t\treturn jsonEncode(this);');
        parts.push('\t}');

        parts.push('}');

        return parts.join('\n');
    }

    private generateConstructor(className: string, properties: JsonProperty[]): string {
        const params = properties.map(prop => {
            const isNullable = this.isPropertyNullable(prop);
            const required = this.config.nullSafety && !isNullable ? 'required ' : '';
            return `    ${required}this.${prop.name}`;
        }).join(',\n');

        return `\n  ${className}({\n${params},\n  });`;
    }

    private generateFromJsonMethod(className: string, properties: JsonProperty[]): string {
        const factoryMethod = `  factory ${className}.fromJson(Map<String, dynamic> json) {`;

        const parts = [factoryMethod];

        // 添加null检查和断言
        if (this.config.addNullChecks || this.config.useAsserts) {
            parts.push(this.generateValidationCode(properties));
        }

        const returnStatement = `    return ${className}(`;
        parts.push(returnStatement);

        const assignments = properties.map(prop => {
            const jsonKey = prop.name;
            let assignment = `      ${prop.name}: `;

            if (prop.isArray) {
                assignment += this.generateArrayAssignment(prop, jsonKey);
            } else if (prop.isNestedObject && prop.nestedClass) {
                assignment += this.generateNestedObjectAssignment(prop, jsonKey);
            } else {
                assignment += this.generatePrimitiveAssignment(prop, jsonKey);
            }

            return assignment;
        }).join(',\n');

        parts.push(assignments);
        parts.push('    );');
        parts.push('  }');

        return parts.join('\n');
    }

    private generateValidationCode(properties: JsonProperty[]): string {
        const validations: string[] = [];

        for (const prop of properties) {
            const jsonKey = prop.name;
            const isNullable = this.isPropertyNullable(prop);

            if (this.config.addNullChecks && !isNullable) {
                validations.push(`    if (json['${jsonKey}'] == null) {`);
                validations.push(`      throw ArgumentError('${prop.name} cannot be null');`);
                validations.push(`    }`);
            }

            if (this.config.useAsserts && !isNullable) {
                validations.push(`    assert(json['${jsonKey}'] != null, '${prop.name} cannot be null');`);
            }
        }

        return validations.length > 0 ? validations.join('\n') + '\n' : '';
    }

    private generateArrayAssignment(prop: JsonProperty, jsonKey: string): string {
        const isNullable = this.isPropertyNullable(prop);

        if (prop.isNestedObject && prop.arrayElementType) {
            if (isNullable) {
                return `(json['${jsonKey}'] as List<dynamic>?)?.map((e) => ${prop.arrayElementType}.fromJson(e as Map<String, dynamic>)).toList()`;
            } else {
                return `(json['${jsonKey}'] as List<dynamic>).map((e) => ${prop.arrayElementType}.fromJson(e as Map<String, dynamic>)).toList()`;
            }
        } else {
            if (isNullable) {
                return `(json['${jsonKey}'] as List<dynamic>?)?.cast<${prop.arrayElementType}>()`;
            } else {
                return `(json['${jsonKey}'] as List<dynamic>).cast<${prop.arrayElementType}>()`;
            }
        }
    }

    private generateNestedObjectAssignment(prop: JsonProperty, jsonKey: string): string {
        const isNullable = this.isPropertyNullable(prop);

        if (isNullable) {
            return `json['${jsonKey}'] != null ? ${prop.nestedClass!.name}.fromJson(json['${jsonKey}'] as Map<String, dynamic>) : null`;
        } else {
            return `${prop.nestedClass!.name}.fromJson(json['${jsonKey}'] as Map<String, dynamic>)`;
        }
    }

    private generatePrimitiveAssignment(prop: JsonProperty, jsonKey: string): string {
        const isNullable = this.isPropertyNullable(prop);
        const dartType = this.getDartTypeWithNullability(prop);

        if (isNullable) {
            return `JsonConvert.fromJsonAsT<${dartType}>(json['${jsonKey}'])`;
        } else {
            return `JsonConvert.fromJsonAsT<${prop.dartType}>(json['${jsonKey}'])!`;
        }
    }

    private generateToJsonMethod(properties: JsonProperty[]): string {
        const methodDeclaration = '  Map<String, dynamic> toJson() {';
        const mapDeclaration = '    return <String, dynamic>{';
        
        const assignments = properties.map(prop => {
            const jsonKey = prop.name;
            let assignment = `      '${jsonKey}': `;
            
            if (prop.isArray && prop.isNestedObject) {
                assignment += `${prop.name}?.map((e) => e.toJson()).toList()`;
            } else if (prop.isNestedObject) {
                assignment += `${prop.name}?.toJson()`;
            } else {
                assignment += prop.name;
            }
            
            return assignment;
        }).join(',\n');
        
        return [
            methodDeclaration,
            mapDeclaration,
            assignments,
            '    };',
            '  }'
        ].join('\n');
    }

    private generateHelperMethods(className: string, properties: JsonProperty[]): string {
        const helperClassName = `${className}Helper`;
        const fromJsonMethod = this.generateHelperFromJson(className, properties);
        const toJsonMethod = this.generateHelperToJson(className, properties);
        
        return `class ${helperClassName} {
${fromJsonMethod}

${toJsonMethod}
}`;
    }

    private generateHelperFromJson(className: string, properties: JsonProperty[]): string {
        return `  static ${className} fromJson(Map<String, dynamic> json) {
    return ${className}(
${properties.map(prop => `      ${prop.name}: JsonConvert.fromJsonAsT<${this.getDartTypeWithNullability(prop)}>(json['${prop.name}'])`).join(',\n')},
    );
  }`;
    }

    private generateHelperToJson(className: string, properties: JsonProperty[]): string {
        return `  static Map<String, dynamic> toJson(${className} entity) {
    return <String, dynamic>{
${properties.map(prop => `      '${prop.name}': entity.${prop.name}`).join(',\n')},
    };
  }`;
    }

    private getClassName(name: string): string {
        return this.config.classNamePrefix + name + this.config.classNameSuffix;
    }

    private getDartTypeWithNullability(prop: JsonProperty): string {
        // 如果强制非空，则不添加?后缀
        if (this.config.forceNonNullable) {
            return prop.dartType;
        }

        // 否则根据null safety和属性的nullable状态决定
        const nullSuffix = this.config.nullSafety && prop.isNullable ? '?' : '';
        return prop.dartType + nullSuffix;
    }

    private isPropertyNullable(prop: JsonProperty): boolean {
        return this.config.nullSafety && prop.isNullable && !this.config.forceNonNullable;
    }

    private generateToStringMethod(className: string, properties: JsonProperty[]): string {
        const propertyStrings = properties.map(prop => `${prop.name}: \$${prop.name}`).join(', ');

        return `  @override
  String toString() {
    return '${className}(${propertyStrings})';
  }`;
    }

    private generateEqualityMethods(className: string, properties: JsonProperty[]): string {
        const equalityChecks = properties.map(prop => `${prop.name} == other.${prop.name}`).join(' && ');
        const hashCodeProps = properties.map(prop => prop.name).join(', ');

        return `  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is ${className} && ${equalityChecks};
  }

  @override
  int get hashCode => Object.hash(${hashCodeProps});`;
    }

    private getDefaultValue(prop: JsonProperty): string {
        if (prop.isArray) {
            return '[]';
        }

        switch (prop.dartType) {
            case 'int':
                return '0';
            case 'double':
                return '0.0';
            case 'String':
                return "''";
            case 'bool':
                return 'false';
            default:
                if (prop.isNestedObject) {
                    return `${prop.dartType}()`;
                }
                return 'null';
        }
    }

    private generateFromJsonFunction(className: string, properties: JsonProperty[]): string {
        const functionName = `$${className}FromJson`;
        const parts = [];

        parts.push(`${className} ${functionName}(Map<String, dynamic> json) {`);
        parts.push(`\tfinal ${className} ${this.toCamelCase(className)} = ${className}();`);

        for (const prop of properties) {
            const jsonKey = prop.name;
            const varName = this.toCamelCase(prop.name);

            if (prop.isArray) {
                if (prop.isNestedObject && prop.arrayElementType) {
                    parts.push(`\tfinal List<${prop.arrayElementType}>? ${varName} = (json['${jsonKey}'] as List<dynamic>?)?.map((e) => ${prop.arrayElementType}.fromJson(e as Map<String, dynamic>)).toList();`);
                } else {
                    parts.push(`\tfinal List<${prop.arrayElementType}>? ${varName} = jsonConvert.convert<List<${prop.arrayElementType}>>(json['${jsonKey}']);`);
                }
            } else if (prop.isNestedObject && prop.nestedClass) {
                parts.push(`\tfinal ${prop.dartType}? ${varName} = jsonConvert.convert<${prop.dartType}>(json['${jsonKey}']);`);
            } else {
                parts.push(`\tfinal ${prop.dartType}? ${varName} = jsonConvert.convert<${prop.dartType}>(json['${jsonKey}']);`);
            }

            parts.push(`\tif (${varName} != null) {`);
            parts.push(`\t\t${this.toCamelCase(className)}.${prop.name} = ${varName};`);
            parts.push(`\t}`);
        }

        parts.push(`\treturn ${this.toCamelCase(className)};`);
        parts.push('}');

        return parts.join('\n');
    }

    private generateToJsonFunction(className: string, properties: JsonProperty[]): string {
        const functionName = `$${className}ToJson`;
        const parts = [];

        parts.push(`Map<String, dynamic> ${functionName}(${className} entity) {`);
        parts.push('\tfinal Map<String, dynamic> data = <String, dynamic>{};');

        for (const prop of properties) {
            if (prop.isArray && prop.isNestedObject) {
                parts.push(`\tdata['${prop.name}'] = entity.${prop.name}?.map((e) => e.toJson()).toList();`);
            } else if (prop.isNestedObject) {
                parts.push(`\tdata['${prop.name}'] = entity.${prop.name}?.toJson();`);
            } else {
                parts.push(`\tdata['${prop.name}'] = entity.${prop.name};`);
            }
        }

        parts.push('\treturn data;');
        parts.push('}');

        return parts.join('\n');
    }

    private generateCopyWithExtension(className: string, properties: JsonProperty[]): string {
        const parts = [];

        parts.push(`extension ${className}Extension on ${className} {`);

        // Generate copyWith method - all parameters are nullable in copyWith
        const params = properties.map(prop => {
            return `\t\t${prop.dartType}? ${prop.name}`;
        }).join(',\n');

        parts.push(`\t${className} copyWith({`);
        parts.push(params + ',');
        parts.push('\t}) {');
        parts.push(`\t\treturn ${className}()`);

        for (const prop of properties) {
            parts.push(`\t\t\t..${prop.name} = ${prop.name} ?? this.${prop.name}`);
        }

        parts.push('\t\t\t;');
        parts.push('\t}');
        parts.push('}');

        return parts.join('\n');
    }

    private toCamelCase(str: string): string {
        return str.charAt(0).toLowerCase() + str.slice(1);
    }

    private generateJsonConvertImports(allClasses: JsonClass[]): string {
        const imports = [];
        for (const cls of allClasses) {
            const className = this.getClassName(cls.name);

            // 检查是否有自定义文件路径（来自扫描的已存在文件）
            const clsWithPath = cls as JsonClass & {filePath?: string};
            if (clsWithPath.filePath) {
                // 使用实际的文件路径
                imports.push(`import 'package:${this.packageName}/${clsWithPath.filePath}.dart';`);
            } else {
                // 使用默认的models路径（新生成的文件）
                const snakeClassName = this.toSnakeCase(className);
                imports.push(`import 'package:${this.packageName}/models/${snakeClassName}.dart';`);
            }
        }
        return imports.join('\n');
    }

    private generateGetListChildType(allClasses: JsonClass[]): string {
        const parts = [];
        parts.push('  static M? _getListChildType<M>(List<Map<String, dynamic>> data) {');

        for (const cls of allClasses) {
            const className = this.getClassName(cls.name);
            parts.push(`    if (<${className}>[] is M) {`);
            parts.push(`      return data.map<${className}>((Map<String, dynamic> e) =>`);
            parts.push(`          ${className}.fromJson(e)).toList() as M;`);
            parts.push(`    }`);
        }

        parts.push('');
        parts.push('    debugPrint("$M not found");');
        parts.push('');
        parts.push('    return null;');
        parts.push('  }');

        return parts.join('\n');
    }

    private generateConvertFuncMap(allClasses: JsonClass[]): string {
        const parts = [];
        parts.push('class JsonConvertClassCollection {');
        parts.push('  Map<String, JsonConvertFunction> convertFuncMap = {');

        const entries = [];
        for (const cls of allClasses) {
            const className = this.getClassName(cls.name);
            entries.push(`    (${className}).toString(): ${className}.fromJson`);
        }

        parts.push(entries.join(',\n') + ',');
        parts.push('  };');
        parts.push('');
        parts.push('  bool containsKey(String type) {');
        parts.push('    return convertFuncMap.containsKey(type);');
        parts.push('  }');
        parts.push('');
        parts.push('  JsonConvertFunction? operator [](String key) {');
        parts.push('    return convertFuncMap[key];');
        parts.push('  }');
        parts.push('}');

        return parts.join('\n');
    }

    private toSnakeCase(str: string): string {
        return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`).replace(/^_/, '');
    }
}
