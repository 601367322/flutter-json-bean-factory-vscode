import { JsonClass, JsonProperty } from '../parsers/JsonParser';
import * as vscode from 'vscode';

export interface GeneratorConfig {
    nullSafety: boolean;
    useJsonAnnotation: boolean;
    classNamePrefix: string;
    classNameSuffix: string;
    generatedPath: string;
    entityPath: string;
    forceNonNullable: boolean;  // 强制所有字段非空
    addNullChecks: boolean;     // 在fromJson中添加null检查
    useAsserts: boolean;        // 使用assert进行验证
    generateToString: boolean;  // 生成toString方法
    generateEquality: boolean;  // 生成==和hashCode方法
    scanPath: string;           // 扫描现有models的路径
}

export class DartCodeGenerator {
    private config: GeneratorConfig;
    private packageName: string;

    constructor(config?: Partial<GeneratorConfig>, packageName: string = 'your_app') {
        const defaultConfig: GeneratorConfig = {
            nullSafety: true,
            useJsonAnnotation: true,
            classNamePrefix: '',
            classNameSuffix: '',
            generatedPath: 'lib/generated/json',
            entityPath: 'lib/models',
            forceNonNullable: false,
            addNullChecks: true,
            useAsserts: false,
            generateToString: true,
            generateEquality: false,
            scanPath: 'lib'
        };

        this.config = { ...defaultConfig, ...config };
        this.packageName = packageName;
    }

    /**
     * Generate Dart class code (entity file)
     */
        generateDartClass(jsonClass: JsonClass): string {
        const className = this.getClassName(jsonClass.name);
        const allClasses = this.collectAllClasses(jsonClass);
        const imports = this.generateSingleFileImports(className);

        // 生成主类和所有嵌套类在同一个文件中
        const classDeclarations = [];

        // 主类
        const mainClassDeclaration = this.generateEntityClassDeclaration(className, jsonClass.properties);
        classDeclarations.push(mainClassDeclaration);

        // 嵌套类（去除Entity后缀，使用原始类名）
        const processedClassNames = new Set<string>();
        processedClassNames.add(className); // 添加主类名，避免重复

        for (const nestedClass of allClasses.slice(1)) { // 跳过主类
            const nestedClassName = this.getNestedClassName(nestedClass.name);

            // 避免重复的类名
            if (!processedClassNames.has(nestedClassName)) {
                processedClassNames.add(nestedClassName);
                const nestedClassDeclaration = this.generateEntityClassDeclaration(nestedClassName, nestedClass.properties);
                classDeclarations.push(nestedClassDeclaration);
            }
        }

        return [
            imports,
            '',
            classDeclarations.join('\n\n')
        ].join('\n');
    }

    /**
     * Generate helper file for JSON conversion (original style)
     */
    generateHelperFile(jsonClass: JsonClass): string {
        const className = this.getClassName(jsonClass.name);
        const allClasses = this.collectAllClasses(jsonClass);
        const imports = this.generateHelperImports(className, allClasses);

        // 生成所有类的函数（原版风格）
        const allFunctions: string[] = [];
        const processedClasses = new Set<string>();

        for (const cls of allClasses) {
            const clsName = cls === jsonClass ? className : this.getNestedClassName(cls.name);

            // 避免重复生成相同类名的函数
            if (!processedClasses.has(clsName)) {
                processedClasses.add(clsName);

                const fromJsonFunction = this.generateFromJsonFunction(clsName, cls.properties);
                const toJsonFunction = this.generateToJsonFunction(clsName, cls.properties);
                const copyWithExtension = this.generateCopyWithExtension(clsName, cls.properties);

                allFunctions.push(fromJsonFunction);
                allFunctions.push('');
                allFunctions.push(toJsonFunction);
                allFunctions.push('');
                allFunctions.push(copyWithExtension);
                allFunctions.push('');
            }
        }

        return [
            imports,
            '',
            allFunctions.join('\n')
        ].join('\n');
    }

    /**
     * Generate base JSON convert file (original style with dynamic updates)
     */
    generateBaseJsonConvert(allClasses: JsonClass[] = []): string {
        const imports = this.generateJsonConvertImports(allClasses);
        const getListChildType = this.generateGetListChildType(allClasses);
        const convertFuncMap = this.generateConvertFuncMap(allClasses);

        return `// ignore_for_file: non_constant_identifier_names
// ignore_for_file: camel_case_types
// ignore_for_file: prefer_single_quotes

// This file is automatically generated. DO NOT EDIT, all your changes would be lost.
import 'package:flutter/material.dart' show debugPrint;
${imports}

JsonConvert jsonConvert = JsonConvert();

typedef JsonConvertFunction<T> = T Function(Map<String, dynamic> json);
typedef EnumConvertFunction<T> = T Function(String value);
typedef ConvertExceptionHandler = void Function(Object error, StackTrace stackTrace);
extension MapSafeExt<K, V> on Map<K, V> {
  T? getOrNull<T>(K? key) {
    if (!containsKey(key) || key == null) {
      return null;
    } else {
      return this[key] as T?;
    }
  }
}

class JsonConvert {
  static ConvertExceptionHandler? onError;
  JsonConvertClassCollection convertFuncMap = JsonConvertClassCollection();

  /// When you are in the development, to generate a new model class, hot-reload doesn't find new generation model class, you can build on MaterialApp method called jsonConvert. ReassembleConvertFuncMap (); This method only works in a development environment
  /// https://flutter.cn/docs/development/tools/hot-reload
  /// class MyApp extends StatelessWidget {
  ///    const MyApp({Key? key})
  ///        : super(key: key);
  ///
  ///    @override
  ///    Widget build(BuildContext context) {
  ///      jsonConvert.reassembleConvertFuncMap();
  ///      return MaterialApp();
  ///    }
  /// }
  void reassembleConvertFuncMap() {
    bool isReleaseMode = const bool.fromEnvironment('dart.vm.product');
    if (!isReleaseMode) {
      convertFuncMap = JsonConvertClassCollection();
    }
  }

  T? convert<T>(dynamic value, {EnumConvertFunction? enumConvert}) {
    if (value == null) {
      return null;
    }
    if (value is T) {
      return value;
    }
    try {
      return _asT<T>(value, enumConvert: enumConvert);
    } catch (e, stackTrace) {
      debugPrint('asT<\$T> \$e \$stackTrace');
      if (onError != null) {
        onError!(e, stackTrace);
      }
      return null;
    }
  }

  List<T?>? convertList<T>(List<dynamic>? value,
      {EnumConvertFunction? enumConvert}) {
    if (value == null) {
      return null;
    }
    try {
      return value.map((dynamic e) => _asT<T>(e, enumConvert: enumConvert))
          .toList();
    } catch (e, stackTrace) {
      debugPrint('asT<\$T> \$e \$stackTrace');
      if (onError != null) {
        onError!(e, stackTrace);
      }
      return <T>[];
    }
  }

  List<T>? convertListNotNull<T>(dynamic value,
      {EnumConvertFunction? enumConvert}) {
    if (value == null) {
      return null;
    }
    try {
      return (value as List<dynamic>).map((dynamic e) =>
      _asT<T>(e, enumConvert: enumConvert)!).toList();
    } catch (e, stackTrace) {
      debugPrint('asT<\$T> \$e \$stackTrace');
      if (onError != null) {
        onError!(e, stackTrace);
      }
      return <T>[];
    }
  }

  T? _asT<T extends Object?>(dynamic value,
      {EnumConvertFunction? enumConvert}) {
    final String type = T.toString();
    final String valueS = value.toString();
    if (enumConvert != null) {
      return enumConvert(valueS) as T;
    } else if (type == "String") {
      return valueS as T;
    } else if (type == "int") {
      final int? intValue = int.tryParse(valueS);
      if (intValue == null) {
        return double.tryParse(valueS)?.toInt() as T?;
      } else {
        return intValue as T;
      }
    } else if (type == "double") {
      return double.parse(valueS) as T;
    } else if (type == "DateTime") {
      return DateTime.parse(valueS) as T;
    } else if (type == "bool") {
      if (valueS == '0' || valueS == '1') {
        return (valueS == '1') as T;
      }
      return (valueS == 'true') as T;
    } else if (type == "Map" || type.startsWith("Map<")) {
      return value as T;
    } else {
      if (convertFuncMap.containsKey(type)) {
        if (value == null) {
          return null;
        }
        var covertFunc = convertFuncMap[type]!;
        if (covertFunc is Map<String, dynamic>) {
          return covertFunc(value as Map<String, dynamic>) as T;
        } else {
          return covertFunc(Map<String, dynamic>.from(value)) as T;
        }
      } else {
        throw UnimplementedError(
            '\$type unimplemented,you can try running the app again');
      }
    }
  }

  //list is returned by type
${getListChildType}

  static M? fromJsonAsT<M>(dynamic json) {
    if (json is M) {
      return json;
    }
    if (json is List) {
      return _getListChildType<M>(
          json.map((dynamic e) => e as Map<String, dynamic>).toList());
    } else {
      return jsonConvert.convert<M>(json);
    }
  }
}

${convertFuncMap}`;
    }

    /**
     * Generate json_field.dart file (fixed content)
     */
    generateJsonField(): string {
        return `// ignore_for_file: non_constant_identifier_names
// ignore_for_file: camel_case_types
// ignore_for_file: prefer_single_quotes

// This file is automatically generated. DO NOT EDIT, all your changes would be lost.

import 'package:meta/meta_meta.dart';

@Target({TargetKind.classType})
class JsonSerializable {
  const JsonSerializable();
}

@Target({TargetKind.field})
class JSONField {
  //Specify the parse field name
  final String? name;

  //Whether to participate in toJson
  final bool? serialize;

  //Whether to participate in fromMap
  final bool? deserialize;

  //Whether to participate in copyWith
  final bool? copyWith;

  //Enumeration or not
  final bool? isEnum;

  const JSONField({this.name, this.serialize, this.deserialize, this.isEnum, this.copyWith});
}`;
    }

    private generateSingleFileImports(className: string): string {
        const snakeClassName = this.toSnakeCase(className);
        return `import 'package:${this.packageName}/generated/json/base/json_field.dart';
import 'package:${this.packageName}/generated/json/${snakeClassName}.g.dart';
import 'dart:convert';
export 'package:${this.packageName}/generated/json/${snakeClassName}.g.dart';`;
    }

    private getNestedClassName(originalName: string): string {
        // 1:1还原原版插件逻辑
        // 原版逻辑：嵌套类名 = parentName + fieldTypeName
        // 其中fieldTypeName是通过FieldUtils.toFieldTypeName(key)生成的

        // 移除主类名前缀，保留字段类型名
        // 例如：GroupListGroupListItem -> GroupListItem -> Group (去掉Item后缀)
        //      GroupListGroupListItemUserListItem -> UserListItem -> UserInfo

        // 先移除重复的前缀
        let className = originalName;

        // 查找重复的模式并移除
        const parts = className.split(/(?=[A-Z])/);
        if (parts.length > 2) {
            // 寻找重复的前缀模式
            const firstHalf = parts.slice(0, Math.floor(parts.length / 2)).join('');
            const secondHalf = parts.slice(Math.floor(parts.length / 2)).join('');

            if (className.startsWith(firstHalf + firstHalf)) {
                // 如果有重复前缀，移除一个
                className = className.substring(firstHalf.length);
            }
        }

        // 通用规则：如果以Item结尾，去掉Item；否则保持原样
        if (className.endsWith('Item')) {
            return className.substring(0, className.length - 4);
        }

        return className;
    }

    private collectAllClasses(jsonClass: JsonClass): JsonClass[] {
        const allClasses: JsonClass[] = [jsonClass];
        const visited = new Set<string>();

        const collectNested = (cls: JsonClass) => {
            if (visited.has(cls.name)) return;
            visited.add(cls.name);

            for (const prop of cls.properties) {
                if (prop.nestedClass) {
                    allClasses.push(prop.nestedClass);
                    collectNested(prop.nestedClass);
                }
            }

            for (const nestedClass of cls.nestedClasses) {
                allClasses.push(nestedClass);
                collectNested(nestedClass);
            }
        };

        collectNested(jsonClass);
        return allClasses;
    }

    private generateHelperImports(className: string, allClasses: JsonClass[]): string {
        const imports = [`import 'package:${this.packageName}/generated/json/base/json_convert_content.dart';`];

        // 只导入主文件，嵌套类都在主文件中（原版风格）
        const mainClass = allClasses[0]; // 主类
        const entityClassName = this.getClassName(mainClass.name);
        const snakeClassName = this.toSnakeCase(entityClassName);
        imports.push(`import 'package:${this.packageName}/models/${snakeClassName}.dart';`);

        return imports.join('\n');
    }

    private generateEntityClassDeclaration(className: string, properties: JsonProperty[]): string {
        const parts = [];

        // Add @JsonSerializable() annotation
        parts.push('@JsonSerializable()');
        parts.push(`class ${className} {`);

        // Add properties with default values (original style)
        for (const prop of properties) {
            const defaultValue = this.getDefaultValue(prop);

            // 检查是否需要@JSONField注解（原始JSON key与驼峰字段名不同）
            const camelCaseName = this.toCamelCase(prop.originalJsonKey);
            const needsJsonField = camelCaseName !== prop.originalJsonKey;

            // 添加@JSONField注解（如果需要），使用单引号（原版风格）
            if (needsJsonField) {
                parts.push(`\t@JSONField(name: '${prop.originalJsonKey}')`);
            }

            // 使用驼峰命名的字段名
            const fieldName = needsJsonField ? camelCaseName : prop.originalJsonKey;

            // 修正字段类型，在单文件模式下使用简洁的类名
            let fieldType = prop.dartType;
            if (prop.isArray && prop.arrayElementType && prop.isNestedObject) {
                const simpleElementType = this.getNestedClassName(prop.arrayElementType);
                fieldType = `List<${simpleElementType}>`;
            } else if (prop.isNestedObject) {
                const simpleType = this.getNestedClassName(prop.dartType);
                fieldType = simpleType;
            }

            // 生成字段声明（原版风格）
            if (prop.isNestedObject && !prop.isArray) {
                // 对象字段使用late关键字（原版风格）
                parts.push(`\t${fieldType.includes('late ') ? '' : 'late '}${fieldType} ${fieldName};`);
            } else if (prop.dartType === 'dynamic') {
                // dynamic字段不设置默认值（原版风格）
                parts.push(`\t${fieldType} ${fieldName};`);
            } else {
                // 其他字段使用默认值
                const correctedDefaultValue = prop.isArray ? '[]' : defaultValue;
                parts.push(`\t${fieldType} ${fieldName} = ${correctedDefaultValue};`);
            }
        }

        parts.push('');
        parts.push(`\t${className}();`);
        parts.push('');

        // Add factory fromJson method that calls global function
        const functionName = `$${className}FromJson`;
        parts.push(`\tfactory ${className}.fromJson(Map<String, dynamic> json) => ${functionName}(json);`);
        parts.push('');

        // Add toJson method that calls global function
        const toJsonFunctionName = `$${className}ToJson`;
        parts.push(`\tMap<String, dynamic> toJson() => ${toJsonFunctionName}(this);`);
        parts.push('');

        // Add toString method using jsonEncode
        parts.push('\t@override');
        parts.push('\tString toString() {');
        parts.push('\t\treturn jsonEncode(this);');
        parts.push('\t}');

        parts.push('}');

        return parts.join('\n');
    }

    private generateConstructor(className: string, properties: JsonProperty[]): string {
        const params = properties.map(prop => {
            const isNullable = this.isPropertyNullable(prop);
            const required = this.config.nullSafety && !isNullable ? 'required ' : '';
            return `    ${required}this.${prop.name}`;
        }).join(',\n');

        return `\n  ${className}({\n${params},\n  });`;
    }

    private generateFromJsonMethod(className: string, properties: JsonProperty[]): string {
        const factoryMethod = `  factory ${className}.fromJson(Map<String, dynamic> json) {`;

        const parts = [factoryMethod];

        // 添加null检查和断言
        if (this.config.addNullChecks || this.config.useAsserts) {
            parts.push(this.generateValidationCode(properties));
        }

        const returnStatement = `    return ${className}(`;
        parts.push(returnStatement);

        const assignments = properties.map(prop => {
            const jsonKey = prop.name;
            let assignment = `      ${prop.name}: `;

            if (prop.isArray) {
                assignment += this.generateArrayAssignment(prop, jsonKey);
            } else if (prop.isNestedObject && prop.nestedClass) {
                assignment += this.generateNestedObjectAssignment(prop, jsonKey);
            } else {
                assignment += this.generatePrimitiveAssignment(prop, jsonKey);
            }

            return assignment;
        }).join(',\n');

        parts.push(assignments);
        parts.push('    );');
        parts.push('  }');

        return parts.join('\n');
    }

    private generateValidationCode(properties: JsonProperty[]): string {
        const validations: string[] = [];

        for (const prop of properties) {
            const jsonKey = prop.name;
            const isNullable = this.isPropertyNullable(prop);

            if (this.config.addNullChecks && !isNullable) {
                validations.push(`    if (json['${jsonKey}'] == null) {`);
                validations.push(`      throw ArgumentError('${prop.name} cannot be null');`);
                validations.push(`    }`);
            }

            if (this.config.useAsserts && !isNullable) {
                validations.push(`    assert(json['${jsonKey}'] != null, '${prop.name} cannot be null');`);
            }
        }

        return validations.length > 0 ? validations.join('\n') + '\n' : '';
    }

    private generateArrayAssignment(prop: JsonProperty, jsonKey: string): string {
        const isNullable = this.isPropertyNullable(prop);

        if (prop.isNestedObject && prop.arrayElementType) {
            if (isNullable) {
                return `(json['${jsonKey}'] as List<dynamic>?)?.map((e) => ${prop.arrayElementType}.fromJson(e as Map<String, dynamic>)).toList()`;
            } else {
                return `(json['${jsonKey}'] as List<dynamic>).map((e) => ${prop.arrayElementType}.fromJson(e as Map<String, dynamic>)).toList()`;
            }
        } else {
            if (isNullable) {
                return `(json['${jsonKey}'] as List<dynamic>?)?.cast<${prop.arrayElementType}>()`;
            } else {
                return `(json['${jsonKey}'] as List<dynamic>).cast<${prop.arrayElementType}>()`;
            }
        }
    }

    private generateNestedObjectAssignment(prop: JsonProperty, jsonKey: string): string {
        const isNullable = this.isPropertyNullable(prop);

        if (isNullable) {
            return `json['${jsonKey}'] != null ? ${prop.nestedClass!.name}.fromJson(json['${jsonKey}'] as Map<String, dynamic>) : null`;
        } else {
            return `${prop.nestedClass!.name}.fromJson(json['${jsonKey}'] as Map<String, dynamic>)`;
        }
    }

    private generatePrimitiveAssignment(prop: JsonProperty, jsonKey: string): string {
        const isNullable = this.isPropertyNullable(prop);
        const dartType = this.getDartTypeWithNullability(prop);

        if (isNullable) {
            return `JsonConvert.fromJsonAsT<${dartType}>(json['${jsonKey}'])`;
        } else {
            return `JsonConvert.fromJsonAsT<${prop.dartType}>(json['${jsonKey}'])!`;
        }
    }

    private generateToJsonMethod(properties: JsonProperty[]): string {
        const methodDeclaration = '  Map<String, dynamic> toJson() {';
        const mapDeclaration = '    return <String, dynamic>{';
        
        const assignments = properties.map(prop => {
            const jsonKey = prop.name;
            let assignment = `      '${jsonKey}': `;
            
            if (prop.isArray && prop.isNestedObject) {
                assignment += `${prop.name}?.map((e) => e.toJson()).toList()`;
            } else if (prop.isNestedObject) {
                assignment += `${prop.name}?.toJson()`;
            } else {
                assignment += prop.name;
            }
            
            return assignment;
        }).join(',\n');
        
        return [
            methodDeclaration,
            mapDeclaration,
            assignments,
            '    };',
            '  }'
        ].join('\n');
    }

    private generateHelperMethods(className: string, properties: JsonProperty[]): string {
        const helperClassName = `${className}Helper`;
        const fromJsonMethod = this.generateHelperFromJson(className, properties);
        const toJsonMethod = this.generateHelperToJson(className, properties);
        
        return `class ${helperClassName} {
${fromJsonMethod}

${toJsonMethod}
}`;
    }

    private generateHelperFromJson(className: string, properties: JsonProperty[]): string {
        return `  static ${className} fromJson(Map<String, dynamic> json) {
    return ${className}(
${properties.map(prop => `      ${prop.name}: JsonConvert.fromJsonAsT<${this.getDartTypeWithNullability(prop)}>(json['${prop.name}'])`).join(',\n')},
    );
  }`;
    }

    private generateHelperToJson(className: string, properties: JsonProperty[]): string {
        return `  static Map<String, dynamic> toJson(${className} entity) {
    return <String, dynamic>{
${properties.map(prop => `      '${prop.name}': entity.${prop.name}`).join(',\n')},
    };
  }`;
    }

    private getClassName(name: string): string {
        return this.config.classNamePrefix + name + this.config.classNameSuffix;
    }

    private getDartTypeWithNullability(prop: JsonProperty): string {
        // 如果强制非空，则不添加?后缀
        if (this.config.forceNonNullable) {
            return prop.dartType;
        }

        // 否则根据null safety和属性的nullable状态决定
        const nullSuffix = this.config.nullSafety && prop.isNullable ? '?' : '';
        return prop.dartType + nullSuffix;
    }

    private isPropertyNullable(prop: JsonProperty): boolean {
        return this.config.nullSafety && prop.isNullable && !this.config.forceNonNullable;
    }

    private generateToStringMethod(className: string, properties: JsonProperty[]): string {
        const propertyStrings = properties.map(prop => `${prop.name}: \$${prop.name}`).join(', ');

        return `  @override
  String toString() {
    return '${className}(${propertyStrings})';
  }`;
    }

    private generateEqualityMethods(className: string, properties: JsonProperty[]): string {
        const equalityChecks = properties.map(prop => `${prop.name} == other.${prop.name}`).join(' && ');
        const hashCodeProps = properties.map(prop => prop.name).join(', ');

        return `  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is ${className} && ${equalityChecks};
  }

  @override
  int get hashCode => Object.hash(${hashCodeProps});`;
    }

    private getDefaultValue(prop: JsonProperty): string {
        // Check for custom default values from settings
        const customConfig = this.config as any;

        if (prop.isArray) {
            return customConfig.listDefaultValue || '[]';
        }

        switch (prop.dartType) {
            case 'int':
                return customConfig.intDefaultValue || '0';
            case 'double':
                return customConfig.intDefaultValue || '0.0';
            case 'String':
                return customConfig.stringDefaultValue || "''";
            case 'bool':
                return customConfig.boolDefaultValue || 'false';
            default:
                if (prop.isNestedObject) {
                    // 为嵌套对象添加Entity后缀
                    const entityClassName = prop.dartType + this.config.classNameSuffix;
                    return `${entityClassName}()`;
                }
                return 'null';
        }
    }

    private generateFromJsonFunction(className: string, properties: JsonProperty[]): string {
        const functionName = `$${className}FromJson`;
        const parts = [];

        parts.push(`${className} ${functionName}(Map<String, dynamic> json) {`);
        const instanceName = className.charAt(0).toLowerCase() + className.slice(1);
        parts.push(`\tfinal ${className} ${instanceName} = ${className}();`);

        for (const prop of properties) {
            const jsonKey = prop.originalJsonKey; // 原始JSON key
            const camelCaseName = this.toCamelCase(prop.originalJsonKey);
            const fieldName = camelCaseName !== prop.originalJsonKey ? camelCaseName : prop.originalJsonKey; // 使用驼峰命名的字段名
            const varName = this.toCamelCase(prop.originalJsonKey);

            // 对于dynamic类型，不添加?标记（原版风格）
            const typeNullString = prop.dartType === 'dynamic' ? '' : '?';

            if (prop.isArray) {
                if (prop.isNestedObject && prop.arrayElementType) {
                    // 对于嵌套对象数组，使用简洁的类名（单文件模式）
                    const simpleElementType = this.getNestedClassName(prop.arrayElementType);
                    parts.push(`\tfinal List<${simpleElementType}>${typeNullString} ${varName} = (json['${jsonKey}'] as List<dynamic>?)?.map((e) => jsonConvert.convert<${simpleElementType}>(e) as ${simpleElementType}).toList();`);
                } else {
                    // 对于基础类型数组
                    parts.push(`\tfinal List<${prop.arrayElementType}>${typeNullString} ${varName} = jsonConvert.convert<List<${prop.arrayElementType}>>(json['${jsonKey}']);`);
                }
            } else if (prop.isNestedObject && prop.nestedClass) {
                const simpleType = this.getNestedClassName(prop.dartType);
                parts.push(`\tfinal ${simpleType}${typeNullString} ${varName} = jsonConvert.convert<${simpleType}>(json['${jsonKey}']);`);
            } else {
                parts.push(`\tfinal ${prop.dartType}${typeNullString} ${varName} = jsonConvert.convert<${prop.dartType}>(json['${jsonKey}']);`);
            }

            // 对于dynamic类型，不需要null检查（原版风格）
            if (prop.dartType === 'dynamic') {
                parts.push(`\t${instanceName}.${fieldName} = ${varName};`);
            } else {
                parts.push(`\tif (${varName} != null) {`);
                parts.push(`\t\t${instanceName}.${fieldName} = ${varName};`);
                parts.push(`\t}`);
            }
        }

        parts.push(`\treturn ${instanceName};`);
        parts.push('}');

        return parts.join('\n');
    }

    private generateToJsonFunction(className: string, properties: JsonProperty[]): string {
        const functionName = `$${className}ToJson`;
        const parts = [];

        parts.push(`Map<String, dynamic> ${functionName}(${className} entity) {`);
        parts.push('\tfinal Map<String, dynamic> data = <String, dynamic>{};');

        for (const prop of properties) {
            const jsonKey = prop.originalJsonKey; // 原始JSON key
            const camelCaseName = this.toCamelCase(prop.originalJsonKey);
            const fieldName = camelCaseName !== prop.originalJsonKey ? camelCaseName : prop.originalJsonKey; // 使用驼峰命名的字段名

            if (prop.isArray && prop.isNestedObject) {
                // 对于数组字段，使用正常的访问（因为有默认值[]）
                parts.push(`\tdata['${jsonKey}'] = entity.${fieldName}.map((v) => v.toJson()).toList();`);
            } else if (prop.isNestedObject) {
                // 对于late字段，使用正常的访问（因为是late初始化）
                parts.push(`\tdata['${jsonKey}'] = entity.${fieldName}.toJson();`);
            } else {
                parts.push(`\tdata['${jsonKey}'] = entity.${fieldName};`);
            }
        }

        parts.push('\treturn data;');
        parts.push('}');

        return parts.join('\n');
    }

    private generateCopyWithExtension(className: string, properties: JsonProperty[]): string {
        const parts = [];

        parts.push(`extension ${className}Extension on ${className} {`);

        // Generate copyWith method - all parameters are nullable in copyWith
        const params = properties.map(prop => {
            const camelCaseName = this.toCamelCase(prop.originalJsonKey);
            const fieldName = camelCaseName !== prop.originalJsonKey ? camelCaseName : prop.originalJsonKey;

            // 确保嵌套类型使用简洁的类名（单文件模式）
            let paramType = prop.dartType;
            if (prop.isArray && prop.arrayElementType && prop.isNestedObject) {
                const simpleElementType = this.getNestedClassName(prop.arrayElementType);
                paramType = `List<${simpleElementType}>`;
            } else if (prop.isNestedObject) {
                paramType = this.getNestedClassName(prop.dartType);
            }

            // 对于dynamic类型，不添加?标记（原版风格）
            const typeNullString = prop.dartType === 'dynamic' ? '' : '?';
            return `\t\t${paramType}${typeNullString} ${fieldName}`;
        }).join(',\n');

        parts.push(`\t${className} copyWith({`);
        parts.push(params + ',');
        parts.push('\t}) {');
        parts.push(`\t\treturn ${className}()`);

        for (const prop of properties) {
            const camelCaseName = this.toCamelCase(prop.originalJsonKey);
            const fieldName = camelCaseName !== prop.originalJsonKey ? camelCaseName : prop.originalJsonKey;
            parts.push(`\t\t\t..${fieldName} = ${fieldName} ?? this.${fieldName}`);
        }

        parts.push('\t\t\t;');
        parts.push('\t}');
        parts.push('}');

        return parts.join('\n');
    }

    private toCamelCase(str: string): string {
        // 将snake_case转换为camelCase
        return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
    }

    private generateJsonConvertImports(allClasses: JsonClass[]): string {
        const imports = [];
        const importedFiles = new Set<string>();

        for (const cls of allClasses) {
            // 导入所有主文件（包括历史类），嵌套类都在主文件中（原版风格）
            const clsWithPath = cls as any;
            const isHistoricalClass = !!clsWithPath.filePath;
            const isNewMainClass = !isHistoricalClass && cls === allClasses.find(c => !(c as any).filePath);

            if (isHistoricalClass || isNewMainClass) {
                let importPath: string;

                if (isHistoricalClass) {
                    // 使用历史类的实际文件路径
                    importPath = `import 'package:${this.packageName}/${clsWithPath.filePath}.dart';`;
                } else {
                    // 使用默认的models路径（新生成的文件）
                    const className = this.getClassName(cls.name);
                    const snakeClassName = this.toSnakeCase(className);
                    importPath = `import 'package:${this.packageName}/models/${snakeClassName}.dart';`;
                }

                if (!importedFiles.has(importPath)) {
                    imports.push(importPath);
                    importedFiles.add(importPath);
                }
            }
        }
        return imports.join('\n');
    }

    private generateGetListChildType(allClasses: JsonClass[]): string {
        const parts = [];
        parts.push('  static M? _getListChildType<M>(List<Map<String, dynamic>> data) {');

        // 为所有主类生成转换（包括历史类），不包含嵌套类（原版风格）
        const processedMainClasses = new Set<string>();
        for (const cls of allClasses) {
            // 判断是否为主类：有filePath属性（历史类）或者是新生成的第一个类（主类）
            const clsWithPath = cls as any;
            const isHistoricalClass = !!clsWithPath.filePath;
            const isNewMainClass = !isHistoricalClass && cls === allClasses.find(c => !(c as any).filePath);

            if (isHistoricalClass || isNewMainClass) {
                // 对于历史类，直接使用类名；对于新类，添加Entity后缀
                const className = isHistoricalClass ? cls.name : this.getClassName(cls.name);

                if (!processedMainClasses.has(className)) {
                    processedMainClasses.add(className);
                    parts.push(`    if (<${className}>[] is M) {`);
                    parts.push(`      return data.map<${className}>((Map<String, dynamic> e) =>`);
                    parts.push(`          ${className}.fromJson(e)).toList() as M;`);
                    parts.push(`    }`);
                }
            }
        }

        parts.push('');
        parts.push('    debugPrint("$M not found");');
        parts.push('');
        parts.push('    return null;');
        parts.push('  }');

        return parts.join('\n');
    }

    private generateConvertFuncMap(allClasses: JsonClass[]): string {
        const parts = [];
        parts.push('class JsonConvertClassCollection {');
        parts.push('  Map<String, JsonConvertFunction> convertFuncMap = {');

        const entries = [];
        // 为所有主类生成映射（包括历史类），不包含嵌套类（原版风格）
        const processedMainClasses = new Set<string>();
        for (const cls of allClasses) {
            // 判断是否为主类：有filePath属性（历史类）或者是新生成的第一个类（主类）
            const clsWithPath = cls as any;
            const isHistoricalClass = !!clsWithPath.filePath;
            const isNewMainClass = !isHistoricalClass && cls === allClasses.find(c => !(c as any).filePath);

            if (isHistoricalClass || isNewMainClass) {
                // 对于历史类，直接使用类名；对于新类，添加Entity后缀
                const className = isHistoricalClass ? cls.name : this.getClassName(cls.name);

                if (!processedMainClasses.has(className)) {
                    processedMainClasses.add(className);
                    entries.push(`    (${className}).toString(): ${className}.fromJson`);
                }
            }
        }

        parts.push(entries.join(',\n') + ',');
        parts.push('  };');
        parts.push('');
        parts.push('  bool containsKey(String type) {');
        parts.push('    return convertFuncMap.containsKey(type);');
        parts.push('  }');
        parts.push('');
        parts.push('  JsonConvertFunction? operator [](String key) {');
        parts.push('    return convertFuncMap[key];');
        parts.push('  }');
        parts.push('}');

        return parts.join('\n');
    }

    private toSnakeCase(str: string): string {
        return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`).replace(/^_/, '');
    }
}
